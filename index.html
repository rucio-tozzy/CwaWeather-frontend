<!DOCTYPE html>
<html lang="zh-TW">

<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">
    <title>é¬¼æ»…å¤©æ°£</title>
    <link rel="icon" type="image/png" href="./icon-v2.png">
    <link rel="apple-touch-icon" href="./icon-v2.png">
    <link rel="apple-touch-icon" sizes="180x180" href="./icon-v2.png">
    <link rel="preconnect" href="https://fonts.googleapis.com">
    <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
    <link href="https://fonts.googleapis.com/css2?family=Noto+Serif+JP:wght@400;700;900&family=Zen+Maru+Gothic:wght@400;700;900&display=swap" rel="stylesheet">

    <style>
        :root {
            /* é¬¼æ»…é¢¨é…è‰² */
            --dm-charcoal: #1E1B18; /* æ·±è‰²èƒŒæ™¯ */
            --dm-green: #0B5A38; /* ç‚­æ²»éƒç¶  */
            --dm-crimson: #8B1C23; /* ç´…è‰²é»ç¶´ */
            --dm-gold: #D9B44A; /* é‡‘è‰²é£¾é‚Š */
            --dm-cream: #F8F1E6; /* å¡ç‰‡åº•è‰² */
            --dm-muted: #9E8F85; /* æ¬¡è‰²æ–‡å­— */
            --dm-card-border: #E6D8CC;
        }

        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
            -webkit-tap-highlight-color: transparent;
        }

        body {
            font-family: 'Noto Serif JP', 'Zen Maru Gothic', sans-serif;
            background-color: var(--dm-charcoal);
            /* èƒŒæ™¯ï¼šæš—è‰² + ç·šæ¢èˆ‡æ³¢æµªç´‹ç† (è¿‘ä¼¼æ°´ä¹‹å‘¼å¸æ„Ÿè¦º) */
            background-image:
                radial-gradient(circle at 10% 10%, rgba(217,180,74,0.07) 0px, transparent 30%),
                repeating-linear-gradient(45deg, rgba(255,255,255,0.02), rgba(255,255,255,0.02) 12px, rgba(255,255,255,0.01) 12px, rgba(255,255,255,0.01) 24px),
                linear-gradient(160deg, rgba(11,90,56,0.08), rgba(139,28,35,0.06));
            min-height: 100vh;
            color: var(--dm-cream);
            overflow-x: hidden;
            padding-bottom: 28px;
        }

        /* é ‚éƒ¨ç‹€æ…‹åˆ— */
        .status-bar {
            display: flex;
            justify-content: space-between;
            align-items: center;
            padding: 15px 20px;
            background: linear-gradient(90deg, rgba(0,0,0,0.45), rgba(0,0,0,0.25));
            backdrop-filter: blur(6px);
            position: sticky;
            top: 0;
            z-index: 100;
        }

        .location-pill {
            background: linear-gradient(90deg,var(--dm-green), rgba(11,90,56,0.8));
            color: #fffbe9;
            padding: 5px 15px;
            border-radius: 20px;
            font-weight: 900;
            font-size: 1.1rem;
            transform: rotate(-2deg);
            border: 2px solid rgba(217,180,74,0.9);
            box-shadow: 0 4px 0 rgba(0,0,0,0.5);
            display: flex;
            align-items: center;
            gap: 8px;
            min-height: 36px;
        }

        .update-pill {
            font-size: 0.85rem;
            color: white;
            background: linear-gradient(90deg, rgba(139,28,35,0.25), rgba(11,90,56,0.12));
            padding: 4px 10px;
            border-radius: 12px;
        }

        .geo-status {
            font-size: 0.8rem;
            color: #fffbe9;
            opacity: 0.95;
            margin-left: 10px;
            background: linear-gradient(90deg, rgba(217,180,74,0.14), rgba(0,0,0,0.08));
            padding: 4px 8px;
            border-radius: 8px;
            border: 1px solid rgba(217,180,74,0.18);
            display: none;
        }

        /* åŸå¸‚ä¸‹æ‹‰ */
        .city-select {
            margin-left: 12px;
            /* è·Ÿ location-pill èåˆï¼šç¶ è‰²æ¼¸å±¤ã€å¥¶è‰²å­—é«”ã€é‡‘è‰²é‚Šç·š */
            background: linear-gradient(90deg, var(--dm-green), rgba(11,90,56,0.9));
            color: #fffbe9;
            border: 1px solid rgba(217,180,74,0.9);
            padding: 6px 34px 6px 10px; /* å³å´ç•™çµ¦ç®­é ­ */
            border-radius: 12px;
            font-weight: 800;
            font-family: inherit;
            outline: none;
            -webkit-appearance: none;
            appearance: none;
            min-width: 140px;
            cursor: pointer;
            box-shadow: 0 6px 18px rgba(0,0,0,0.45);
            background-image: url("data:image/svg+xml,%3Csvg xmlns='http://www.w3.org/2000/svg' width='18' height='18' viewBox='0 0 24 24'%3E%3Cpath d='M6 9l6 6 6-6' stroke='%23D9B44A' stroke-width='2.2' fill='none' stroke-linecap='round' stroke-linejoin='round'/%3E%3C/svg%3E");
            background-repeat: no-repeat;
            background-position: right 10px center;
        }

        .city-select option {
            /* æ”¹æˆæ·ºåº•æ·±å­—ï¼Œæå‡å¯è®€æ€§ï¼ˆèˆ‡ location-pill ç›¸å®¹ï¼‰ */
            background: var(--dm-cream);
            color: var(--dm-charcoal);
            padding: 8px 10px;
            font-weight: 700;
        }

        /* RWD: small screens â€” select becomes full-width and stacked */
        @media (max-width: 480px) {
            .status-bar { padding: 12px; gap: 6px; }
            .status-bar > div:first-child { display: flex; flex-direction: column; gap: 6px; align-items: flex-start; }
            .location-pill { transform: none; font-size: 1rem; }
            .city-select { display: block !important; width: calc(100% - 12px); margin-left: 0; margin-top: 4px; min-width: 0; padding-left:12px; padding-right:44px }
            .update-pill { margin-left: 0; }
        }

        .location-pill .loc-icon { margin-left: 2px; }
        .location-pill .loc-name { font-weight: 900; }
        .location-pill .loc-suffix { font-weight: 700; opacity: 0.95; font-size:0.95rem; color:#fff7e6 }

        .container {
            padding: 20px;
            max-width: 600px;
            /* é™åˆ¶åœ¨å¤§æ‰‹æ©Ÿå¯¬åº¦ */
            margin: 0 auto;
        }

        /* === æ ¸å¿ƒï¼šä»Šæ—¥ç„¦é»å¡ç‰‡ === */
        .hero-card {
            background: linear-gradient(180deg, rgba(248,241,230,0.98), rgba(248,241,230,0.94));
            border-radius: 22px;
            padding: 26px 22px;
            text-align: center;
            box-shadow: 0 12px 30px rgba(0, 0, 0, 0.45);
            border: 3px solid rgba(217,180,74,0.6);
            margin-bottom: 25px;
            position: relative;
        }

        /* åƒå‹•æ£®çš„å°è©±æ°£æ³¡ */
        .hero-period {
            position: absolute;
            top: -15px;
            left: 50%;
            transform: translateX(-50%);
            background: linear-gradient(90deg, rgba(139,28,35,0.95), rgba(11,90,56,0.95));
            color: #fffbe9;
            padding: 5px 20px;
            border-radius: 20px;
            font-weight: bold;
            border: 3px solid rgba(0,0,0,0.45);
            box-shadow: 0 4px 0 rgba(0, 0, 0, 0.1);
        }

        .hero-temp-container {
            display: flex;
            justify-content: center;
            align-items: center;
            gap: 10px;
            margin: 15px 0;
        }

        .hero-icon {
            font-size: 5rem;
            filter: drop-shadow(0 4px 0 rgba(0, 0, 0, 0.1));
            animation: bounce 3s infinite;
        }

        @keyframes bounce {

            0%,
            100% {
                transform: translateY(0);
            }

            50% {
                transform: translateY(-10px);
            }
        }

        .hero-temp {
            font-size: 4.5rem;
            font-weight: 900;
            color: var(--dm-crimson);
            line-height: 1;
        }

        .hero-desc {
            font-size: 1.4rem;
            color: var(--dm-muted);
            margin-bottom: 20px;
            font-weight: bold;
        }

        /* === ä¸Šç­æ—æœ€æ„›çš„ï¼šå¿«é€Ÿå»ºè­°å€ === */
        .advice-grid {
            display: grid;
            grid-template-columns: 1fr 1fr;
            gap: 15px;
            margin-top: 20px;
            padding-top: 20px;
            border-top: 2px dashed #E0D8C0;
        }

        .advice-item {
            display: flex;
            flex-direction: column;
            align-items: center;
            background: linear-gradient(180deg, rgba(255,255,255,0.9), rgba(255,255,255,0.85));
            padding: 10px;
            border-radius: 20px;
        }

        .advice-icon {
            font-size: 2rem;
            margin-bottom: 5px;
        }

        .advice-text {
            font-size: 1.25rem;
            font-weight: 900;
            color: var(--dm-crimson);
            margin: 5px 0;
            line-height: 1.2;
        }

        /* === ç¨å¾Œé å ±ï¼šæ©«å‘æ»‘å‹•å€ === */
        .section-title {
            font-size: 1.1rem;
            color: #ffefd5;
            margin-bottom: 15px;
            margin-left: 10px;
            font-weight: 900;
            text-shadow: 1px 1px 0 rgba(0, 0, 0, 0.1);
        }

        .scroll-container {
            display: flex;
            overflow-x: auto;
            gap: 15px;
            padding-bottom: 10px;
            /* éš±è—æ»¾å‹•æ¢ä½†ä¿ç•™åŠŸèƒ½ */
            scrollbar-width: none;
            -ms-overflow-style: none;
        }

        .scroll-container::-webkit-scrollbar {
            display: none;
        }

        .mini-card {
            min-width: 140px;
            background: rgba(255, 255, 255, 0.85);
            border-radius: 25px;
            padding: 20px 15px;
            text-align: center;
            border: 2px solid rgba(0,0,0,0.12);
            flex-shrink: 0;
            /* é˜²æ­¢è¢«æ“ å£“ */
        }

        .mini-time {
            background: linear-gradient(90deg, rgba(11,90,56,0.95), rgba(139,28,35,0.95));
            color: #fffbe9;
            padding: 3px 10px;
            border-radius: 10px;
            font-size: 0.8rem;
            display: inline-block;
            margin-bottom: 10px;
            font-weight: bold;
        }

        .mini-icon {
            font-size: 2.5rem;
            margin: 5px 0;
        }

        .mini-temp {
            font-size: 1.2rem;
            font-weight: 800;
            color: var(--dm-charcoal);
        }

        /* Loading ç•«é¢ */
        .loading-screen {
            position: fixed;
            top: 0;
            left: 0;
            right: 0;
            bottom: 0;
            background: linear-gradient(180deg,var(--dm-charcoal), rgba(11,90,56,0.15));
            display: flex;
            flex-direction: column;
            justify-content: center;
            align-items: center;
            z-index: 999;
        }

        /* å°å‹è£é£¾ï¼šç‚­æ²»éƒæ ¼ç´‹ï¼ˆè¿‘ä¼¼ï¼‰ */
        .checkered-band {
            height: 12px;
            width: 80%;
            margin: 18px auto 0;
            border-radius: 8px;
            background-image: repeating-linear-gradient(45deg, rgba(11,90,56,0.95) 0 12px, rgba(0,0,0,0.6) 12px 24px);
            box-shadow: 0 4px 20px rgba(0,0,0,0.5) inset;
        }
    </style>
</head>

<body>
    <div id="loading" class="loading-screen">
        <div style="font-size: 4rem; animation: bounce 2s infinite;">ğŸŒŠğŸ—¡ï¸</div>
        <p style="color: #ffefd5; font-weight: 900; margin-top: 20px; font-size:1rem;">é¬¼æ®ºéšŠæ­£åœ¨å·¡å¯Ÿå¤©å€™ä¸­â€¦</p>
        <div class="checkered-band" aria-hidden="true"></div>
    </div>
    <div class="status-bar">
            <div style="display:flex; align-items:center; gap:8px;">
            <div class="location-pill">
                <span class="loc-icon">ğŸ“</span>
                <span id="locName" class="loc-name">è‡ºåŒ—å¸‚</span>
                <select id="citySelect" class="city-select" aria-label="é¸æ“‡åŸå¸‚" style="display:none">
                    <option>è¼‰å…¥åŸå¸‚...</option>
                </select>
                <span class="loc-suffix"> â€” æ—¥ä¹‹å‘¼å¸</span>
            </div>
        </div>
        <div style="display:flex; align-items:center; gap:8px;">
            <div id="updateTime" class="update-pill">æ›´æ–°ä¸­...</div>
            <div id="geoStatus" class="geo-status" aria-hidden="true"></div>
        </div>
    </div>

    <div class="container" id="mainContent" style="display: none;">

        <div id="heroCard">
        </div>
        <div class="checkered-band" aria-hidden="true" style="margin-top:10px;"></div>

        <h3 class="section-title">ç¨å¾Œé å ±ï¼ˆå‘¼å¸æ™‚åˆ»ï¼‰</h3>
        <div class="scroll-container" id="futureForecasts">
        </div>

    </div>

    <script>
        // æ›æˆæ–°çš„å¾Œç«¯ endpointï¼ˆå›å‚³æ‰€æœ‰ç¸£å¸‚æˆ–æ›´å®Œæ•´è³‡æ–™ï¼‰
        const API_URL = "https://rucio-tozzy-cwaweather-backend.zeabur.app/api/weather/all";

        function getWeatherIcon(weather) {
            if (!weather) return "ğŸŒŠ";
            if (weather.includes("æ™´")) return "â˜€ï¸ğŸ—¡ï¸";
            if (weather.includes("å¤šé›²")) return "ğŸŒ¥ï¸";
            if (weather.includes("é™°")) return "â˜ï¸";
            if (weather.includes("é›¨")) return "ğŸŒ§ï¸ğŸ’§";
            if (weather.includes("é›·")) return "â›ˆï¸âš¡";
            if (weather.includes("é›ª")) return "â„ï¸";
            return "ğŸŒŠ";
        }

        function getAdvice(rainProb, maxTemp) {
            let rainIcon = "ğŸŒ€";
            let rainText = "æ™´é›¨ç„¡å¸¸ï¼Œæ–Ÿé…Œæ”œå¸¶";
            if (parseInt(rainProb) > 30) {
                rainIcon = "â˜‚ï¸";
                rainText = "è¨˜å¾—å¸¶å‚˜ï¼";
            }

            let clothIcon = "ğŸ§¥";
            let clothText = "ä¾å¤©å€™è‘—è£";
            if (parseInt(maxTemp) >= 28) {
                clothIcon = "ğŸ½";
                clothText = "çŸ­è¢–å‡ºç™¼";
            } else if (parseInt(maxTemp) <= 20) {
                clothIcon = "ğŸ§¥";
                clothText = "åŠ ä»¶å¤–å¥—";
            }

            return { rainIcon, rainText, clothIcon, clothText };
        }

        function getTimePeriod(startTime) {
            const hour = new Date(startTime).getHours();
            if (hour >= 5 && hour < 11) return "æ—©æ™¨";
            if (hour >= 11 && hour < 14) return "ä¸­åˆ";
            if (hour >= 14 && hour < 18) return "ä¸‹åˆ";
            if (hour >= 18 && hour < 23) return "æ™šä¸Š";
            return "æ·±å¤œ";
        }

        function pickCityData(allData, preferred = /å°åŒ—|è‡ºåŒ—|taipei/i) {
            if (!allData) return null;
            if (allData.forecasts) return allData;

            if (typeof allData === 'object' && !Array.isArray(allData)) {
                for (const k of Object.keys(allData)) {
                    if (preferred.test(k)) return allData[k];
                }

                for (const k of Object.keys(allData)) {
                    const v = allData[k];
                    if (!v) continue;
                    if (v.forecasts) return v;
                    if ((v.city && preferred.test(v.city)) || (v.location && preferred.test(v.location))) return v;
                }
            }

            if (Array.isArray(allData)) {
                for (const item of allData) {
                    if (!item) continue;
                    if (item.forecasts && ((item.city && preferred.test(item.city)) || (item.location && preferred.test(item.location)))) return item;
                }
                const first = allData.find(x => x && x.forecasts);
                if (first) return first;
                return allData[0];
            }

            return null;
        }

        function listCitiesFromAllData(allData) {
            const out = [];
            if (!allData) return out;

            if (allData.forecasts) {
                out.push({ id: '_single', label: allData.city || allData.locationName || allData.name || 'ç•¶åœ°', data: allData });
                return out;
            }

            if (Array.isArray(allData)) {
                allData.forEach((it, idx) => {
                    if (!it) return;
                    const label = it.city || it.locationName || it.name || `åŸå¸‚ ${idx + 1}`;
                    out.push({ id: idx + '', label, data: it });
                });
                return out;
            }

            if (typeof allData === 'object') {
                Object.keys(allData).forEach(k => {
                    const v = allData[k];
                    if (!v) return;
                    const label = (v.city || v.locationName || v.name || k);
                    out.push({ id: k, label, data: v });
                });
                return out;
            }

            return out;
        }

        // --- geolocation helpers ------------------------------------------------
        function haversineDistance(lat1, lon1, lat2, lon2) {
            const toRad = d => d * Math.PI / 180;
            const R = 6371; // km
            const dLat = toRad(lat2 - lat1);
            const dLon = toRad(lon2 - lon1);
            const a = Math.sin(dLat / 2) * Math.sin(dLat / 2) + Math.cos(toRad(lat1)) * Math.cos(toRad(lat2)) * Math.sin(dLon / 2) * Math.sin(dLon / 2);
            const c = 2 * Math.atan2(Math.sqrt(a), Math.sqrt(1 - a));
            return R * c;
        }

        function getCoordsFromCity(item) {
            if (!item) return null;
            // common fields
            const maybe = (o, name) => (o && typeof o[name] !== 'undefined') ? o[name] : undefined;
            const candidates = [ 'lat', 'latitude', 'latLng', 'locationLat', 'y', 'coordLat' ];
            const candidatesLon = [ 'lon', 'lng', 'longitude', 'locationLon', 'x', 'coordLon' ];

            for (const [i, k] of candidates.entries()) {
                const v = maybe(item, k);
                const w = maybe(item, candidatesLon[i]);
                // allow strings that look like numbers (e.g. "23.5")
                const n1 = (typeof v === 'number') ? v : (typeof v === 'string' ? parseFloat(v) : NaN);
                const n2 = (typeof w === 'number') ? w : (typeof w === 'string' ? parseFloat(w) : NaN);
                if (Number.isFinite(n1) && Number.isFinite(n2)) return { lat: n1, lon: n2 };
            }

            // nested possibilities + recursive search for keys containing lat/lon
            if (item.location && typeof item.location.lat === 'number' && typeof item.location.lon === 'number') return { lat: item.location.lat, lon: item.location.lon };
            if (item.geometry && Array.isArray(item.geometry.coordinates)) {
                // GeoJSON [lon, lat]
                const coords = item.geometry.coordinates;
                if (coords.length >= 2 && typeof coords[0] === 'number' && typeof coords[1] === 'number') return { lat: coords[1], lon: coords[0] };
            }

            // æ·±åº¦æœå°‹ï¼šæ‰¾å‡ºåŒ…å« lat/lon æˆ–é¡ä¼¼åç¨±çš„æ•¸å­— pair
            function findLatLonDeep(obj) {
                if (!obj || typeof obj !== 'object') return null;
                if (Array.isArray(obj) && obj.length >= 2 && typeof obj[0] === 'number' && typeof obj[1] === 'number') {
                    const a = obj[0], b = obj[1];
                    if (a >= -90 && a <= 90 && b >= -180 && b <= 180) return { lat: a, lon: b };
                    if (b >= -90 && b <= 90 && a >= -180 && a <= 180) return { lat: b, lon: a };
                }

                for (const key of Object.keys(obj)) {
                    const v = obj[key];
                    if (typeof v === 'number') {
                        const kLower = key.toLowerCase();
                        if (kLower.includes('lat')) {
                            const lonKey = Object.keys(obj).find(kk => kk.toLowerCase().includes('lon') || kk.toLowerCase().includes('lng'));
                            if (lonKey && typeof obj[lonKey] === 'number') return { lat: v, lon: obj[lonKey] };
                        }
                        if (kLower.includes('lon') || kLower.includes('lng')) {
                            const latKey = Object.keys(obj).find(kk => kk.toLowerCase().includes('lat'));
                            if (latKey && typeof obj[latKey] === 'number') return { lat: obj[latKey], lon: v };
                        }
                    }
                    if (typeof v === 'object') {
                        const found = findLatLonDeep(v);
                        if (found) return found;
                    }
                }
                return null;
            }

            const deepFound = findLatLonDeep(item);
            if (deepFound) return deepFound;

            return null;
        }

        function getPositionPromise(timeout = 5000) {
            return new Promise((resolve, reject) => {
                if (!navigator.geolocation) return reject(new Error('Geolocation not supported'));
                let resolved = false;
                const onSuccess = pos => { if (!resolved) { resolved = true; resolve(pos); } };
                const onFail = err => { if (!resolved) { resolved = true; reject(err); } };
                navigator.geolocation.getCurrentPosition(onSuccess, onFail, { enableHighAccuracy: true, maximumAge: 0, timeout });
                setTimeout(() => { if (!resolved) { resolved = true; reject(new Error('geolocation timeout')); } }, timeout + 200);
            });
        }

        function renderWeather(data) {
            const forecasts = data.forecasts;
            const current = forecasts[0];
            const others = forecasts.slice(1);

            // 1. æ¸²æŸ“ Hero Card (ä¸»ç•«é¢)
            const advice = getAdvice(current.rain, current.maxTemp);
            const period = getTimePeriod(current.startTime);
            const avgTemp = Math.round((parseInt(current.maxTemp) + parseInt(current.minTemp)) / 2);

            document.getElementById('heroCard').innerHTML = `
                        <div class="hero-card">
                            <div class="hero-period">${period}</div>
                            <div class="hero-temp-container">
                                <div class="hero-icon">${getWeatherIcon(current.weather)}</div>
                                <div class="hero-temp">${avgTemp}Â°</div>
                            </div>
                            <div class="hero-desc">${current.weather}</div>
                            
                            <div class="advice-grid">
                                <div class="advice-item">
                                    <div class="advice-icon">${advice.rainIcon}</div>
                                    <div class="advice-text">${advice.rainText}</div>
                                    <div style="font-size:0.7rem; color:#999">é™é›¨ç‡ ${current.rain}</div>
                                </div>
                                <div class="advice-item">
                                    <div class="advice-icon">${advice.clothIcon}</div>
                                    <div class="advice-text">${advice.clothText}</div>
                                    <div style="font-size:0.7rem; color:#999">æœ€é«˜æº« ${current.maxTemp}Â°</div>
                                </div>
                            </div>
                        </div>
                    `;
                        const gs = document.getElementById('geoStatus');
                        if (gs) { gs.textContent = 'å®šä½æˆåŠŸ'; gs.style.display='inline-block'; setTimeout(()=>gs.style.display='none',6000); }

            // 2. æ¸²æŸ“ç¨å¾Œé å ± (åŒ…å«æ˜å¤©åˆ¤æ–·)
            const scrollContainer = document.getElementById('futureForecasts');
            scrollContainer.innerHTML = '';

            // æŠ“ä»Šå¤©çš„æ—¥æœŸæ•¸å­— (ä¾‹å¦‚ 24)
            const todayDate = new Date().getDate();

            others.forEach(f => {
                let p = getTimePeriod(f.startTime);

                // åˆ¤æ–·è©²é å ±çš„æ—¥æœŸæ˜¯å¦è·Ÿä»Šå¤©ä¸åŒï¼Œä¸åŒå°±æ˜¯æ˜å¤©
                const fDate = new Date(f.startTime);
                if (fDate.getDate() !== todayDate) {
                    p = "æ˜å¤©" + p;
                }

                scrollContainer.innerHTML += `
                            <div class="mini-card">
                                <div class="mini-time">${p}</div>
                                <div class="mini-icon">${getWeatherIcon(f.weather)}</div>
                                <div class="mini-temp">${f.minTemp}Â° - ${f.maxTemp}Â°</div>
                                <div style="font-size:0.8rem; color:#888; margin-top:5px;">ğŸ’§${f.rain}</div>
                            </div>
                        `;
            });

            // 3. å³ä¸Šè§’é¡¯ç¤ºä»Šæ—¥æ—¥æœŸ
            const now = new Date();
            const month = now.getMonth() + 1;
            const date = now.getDate();
            const dayIndex = now.getDay();
            const days = ["é€±æ—¥", "é€±ä¸€", "é€±äºŒ", "é€±ä¸‰", "é€±å››", "é€±äº”", "é€±å…­"];

            // å³ä¸Šåƒ…é¡¯ç¤ºæ—¥æœŸï¼ˆä¸é¡¯ç¤ºåœ°å€è³‡è¨Šï¼‰
            document.getElementById('updateTime').textContent = `${month}æœˆ${date}æ—¥ ${days[dayIndex]}`;
        }

        async function fetchWeather() {
            try {
                // 1. å®šç¾©ã€Œæœ€ä½ç­‰å¾…æ™‚é–“ã€ï¼š1500 æ¯«ç§’ (1.5ç§’)
                const delayPromise = new Promise(resolve => setTimeout(resolve, 1500));

                // 2. å®šç¾©ã€ŒæŠ“å–è³‡æ–™ã€çš„å·¥ä½œ
                const fetchPromise = fetch(API_URL).then(res => res.json());

                // 3. Promise.all æœƒç­‰å¾…ã€Œå…©å€‹éƒ½å®Œæˆã€æ‰æœƒå¾€ä¸‹èµ°
                // result é™£åˆ—è£¡ï¼Œç¬¬ä¸€å€‹æ˜¯ delay çš„çµæœ(æ²’ç”¨åˆ°)ï¼Œç¬¬äºŒå€‹æ˜¯ api çš„ json è³‡æ–™
                const [_, json] = await Promise.all([delayPromise, fetchPromise]);

                if (json.success) {
                    // æ”¯æ´ /api/weather/all å›å‚³ï¼šè‹¥ç‚ºå¤šåŸå¸‚è³‡æ–™ï¼Œç”¢ç”Ÿä¸‹æ‹‰é¸å–®
                    const cities = listCitiesFromAllData(json.data);
                    const selectEl = document.getElementById('citySelect');
                    const locNameEl = document.getElementById('locName');

                    if (cities.length > 1) {
                        selectEl.style.display = 'inline-block';
                        locNameEl.style.display = 'none';
                        selectEl.innerHTML = cities.map((c, i) => `<option value="${i}">${c.label}</option>`).join('');

                        // é è¨­é¸è‡ºåŒ—å¸‚ï¼ˆè‹¥å­˜åœ¨ï¼‰ï¼Œå¦å‰‡ 0
                        const defaultIdx = cities.findIndex(c => /å°åŒ—|è‡ºåŒ—|Taipei/i.test(c.label) || (c.data && ((c.data.city && /å°åŒ—|è‡ºåŒ—|Taipei/i.test(c.data.city)) || (c.data.name && /å°åŒ—|è‡ºåŒ—|Taipei/i.test(c.data.name)))));
                        selectEl.selectedIndex = defaultIdx >= 0 ? defaultIdx : 0;
                        // å…ˆç”¨é è¨­æ¸²æŸ“ï¼Œæ¥è‘—å˜—è©¦ç”¨ geolocation æ›´æ–°æˆæœ€è¿‘åŸå¸‚
                        renderWeather(cities[selectEl.selectedIndex].data);

                        // å˜—è©¦å–å¾—ä½¿ç”¨è€…ä½ç½®ï¼ˆè‹¥æ¬Šé™å…è¨±ï¼‰ä¸¦æŠŠé¸å–®åˆ‡åˆ°æœ€è¿‘åŸå¸‚
                        getPositionPromise(5000).then(pos => {
                            console.debug('geolocation success', pos && pos.coords);
                            try {
                                const { latitude, longitude } = pos.coords;
                                let bestIdx = -1;
                                let bestDist = Infinity;
                                cities.forEach((c, idx) => {
                                    const coords = getCoordsFromCity(c.data);
                                    if (!coords) return;
                                    const d = haversineDistance(latitude, longitude, coords.lat, coords.lon);
                                    if (d < bestDist) { bestDist = d; bestIdx = idx; }
                                });

                                console.debug('computed bestIdx,dist', bestIdx, bestDist, 'citiesHaveCoords?', cities.map(c=>!!getCoordsFromCity(c.data)));
                                const gs = document.getElementById('geoStatus');
                                if (bestIdx >= 0) {
                                    selectEl.selectedIndex = bestIdx;
                                    if (locNameEl) locNameEl.textContent = cities[bestIdx].label;
                                    renderWeather(cities[bestIdx].data);
                                    if (gs) { gs.textContent = `å·²å®šä½ï¼š${cities[bestIdx].label} ï¼ˆè·é›¢ ${bestDist.toFixed(1)} kmï¼‰`; gs.style.display='inline-block'; setTimeout(()=>gs.style.display='none',6000); }
                                } else {
                                    // è‹¥æ²’å¯æ¯”å°åº§æ¨™è³‡æ–™ï¼Œå…ˆå°å‡ºåŸå¸‚åˆ—è¡¨çœ‹çœ‹æœ‰å“ªäº› label
                                    console.debug('no coords found among cities; will try known-city fallback. city labels:', cities.map(c=>c.label));
                                    // è‹¥æ²’å¯æ¯”å°åº§æ¨™è³‡æ–™ï¼Œå˜—è©¦ç”¨ã€Œå·²çŸ¥åŸå¸‚åº§æ¨™ã€å»é…å° label
                                    const known = {
                                        'è‡ºåŒ—': { lat: 25.0330, lon: 121.5654 },
                                        'é«˜é›„': { lat: 22.6273, lon: 120.3014 },
                                        'å°ä¸­': { lat: 24.1477, lon: 120.6736 },
                                        'å°å—': { lat: 23.0000, lon: 120.2270 },
                                        'æ–°åŒ—': { lat: 25.0169, lon: 121.4628 },
                                        'æ¡ƒåœ’': { lat: 24.9937, lon: 121.3009 },
                                        'åŸºéš†': { lat: 25.1280, lon: 121.7410 },
                                        'å±æ±': { lat: 22.5510, lon: 120.5480 },
                                        'èŠ±è“®': { lat: 23.9760, lon: 121.6040 },
                                        'å®œè˜­': { lat: 24.7590, lon: 121.7570 },
                                        'å˜‰ç¾©': { lat: 23.4800, lon: 120.4490 }
                                    };

                                    let nearestKnown = null;
                                    let nearestDist = Infinity;
                                    Object.keys(known).forEach(k => {
                                        const d = haversineDistance(latitude, longitude, known[k].lat, known[k].lon);
                                        if (d < nearestDist) { nearestDist = d; nearestKnown = k; }
                                    });

                                    if (nearestKnown) {
                                        // æ”¯æ´ä¸­è‹±æ–‡åˆ¥åæ¯”å°
                                        const synonyms = {
                                            'è‡ºåŒ—': ['è‡ºåŒ—', 'å°åŒ—', 'Taipei'],
                                            'æ–°åŒ—': ['æ–°åŒ—', 'New Taipei', 'æ–°åŒ—å¸‚'],
                                            'åŸºéš†': ['åŸºéš†', 'Keelung', 'Keelung City', 'åŸºéš†å¸‚'],
                                            'å®œè˜­': ['å®œè˜­', 'Yilan', 'å®œè˜­ç¸£', 'å®œè˜­å¸‚'],
                                            'æ¡ƒåœ’': ['æ¡ƒåœ’', 'Taoyuan', 'Taoyuan City', 'æ¡ƒåœ’å¸‚'],
                                            'æ–°ç«¹': ['æ–°ç«¹', 'Hsinchu', 'Hsinchu City', 'æ–°ç«¹å¸‚'],
                                            'è‹—æ —': ['è‹—æ —', 'Miaoli'],
                                            'å°ä¸­': ['å°ä¸­', 'è‡ºä¸­', 'Taichung', 'Taichung City'],
                                            'å½°åŒ–': ['å½°åŒ–', 'Changhua'],
                                            'å—æŠ•': ['å—æŠ•', 'Nantou'],
                                            'é›²æ—': ['é›²æ—', 'Yunlin'],
                                            'å˜‰ç¾©': ['å˜‰ç¾©', 'Chiayi', 'Chiayi City', 'å˜‰ç¾©å¸‚'],
                                            'å°å—': ['å°å—', 'è‡ºå—', 'Tainan', 'Tainan City'],
                                            'é«˜é›„': ['é«˜é›„', 'Kaohsiung', 'Kaohsiung City', 'é«˜é›„å¸‚'],
                                            'å±æ±': ['å±æ±', 'Pingtung'],
                                            'èŠ±è“®': ['èŠ±è“®', 'Hualien'],
                                            'å°æ±': ['å°æ±', 'è‡ºæ±', 'Taitung'],
                                            'æ¾æ¹–': ['æ¾æ¹–', 'Penghu'],
                                            'é‡‘é–€': ['é‡‘é–€', 'Kinmen'],
                                            'é€£æ±Ÿ': ['é€£æ±Ÿ', 'Matsu']
                                        };

                                        const aliases = synonyms[nearestKnown] || [nearestKnown];
                                        function matchesAlias(c, aliases) {
                                            const fields = [c.label, c.data && (c.data.city || c.data.name || c.data.locationName), JSON.stringify(c.data)].filter(Boolean).join('||').toLowerCase();
                                            return aliases.some(a => fields.includes(a.toLowerCase()));
                                        }

                                        const foundIdx = cities.findIndex(c => matchesAlias(c, aliases));
                                        // extra fallback: try partial match by first two chars (e.g., åŸºéš† -> åŸºéš†å¸‚ vs åŸºéš†)
                                        let foundIdx2 = -1;
                                        if (foundIdx < 0) {
                                            const simple = nearestKnown.slice(0, 2).toLowerCase();
                                            foundIdx2 = cities.findIndex(c => (c.label && c.label.toLowerCase().includes(simple)) || (c.data && c.data.city && c.data.city.toLowerCase().includes(simple)) || (c.data && c.data.name && c.data.name.toLowerCase().includes(simple)));
                                        }
                                        const finalIdx = (foundIdx >= 0) ? foundIdx : foundIdx2;
                                        console.debug('matched alias idx', foundIdx, 'fallback two-char idx', foundIdx2, 'final', finalIdx);
                                        if (finalIdx >= 0) {
                                            selectEl.selectedIndex = finalIdx;
                                            if (locNameEl) locNameEl.textContent = cities[finalIdx].label;
                                            renderWeather(cities[finalIdx].data);
                                            if (gs) { gs.textContent = `å·²å®šä½ï¼ˆåç¨±æ¯”å°ï¼‰: ${cities[finalIdx].label}`; gs.style.display='inline-block'; setTimeout(()=>gs.style.display='none',6000); }
                                        } else {
                                            selectEl.selectedIndex = defaultIdx >= 0 ? defaultIdx : 0;
                                            renderWeather(cities[selectEl.selectedIndex].data);
                                            if (gs) { gs.textContent = 'å®šä½æˆåŠŸä½†ç„¡æ³•é…å°åŸå¸‚è³‡æ–™ï¼›ä½¿ç”¨é è¨­ã€‚'; gs.style.display='inline-block'; setTimeout(()=>gs.style.display='none',6000); }
                                        }
                                    } else {
                                        selectEl.selectedIndex = defaultIdx >= 0 ? defaultIdx : 0;
                                        renderWeather(cities[selectEl.selectedIndex].data);
                                    }
                                }
                            } catch (e) {
                                selectEl.selectedIndex = defaultIdx >= 0 ? defaultIdx : 0;
                            }
                        }).catch(() => {
                            // å®šä½å¤±æ•—ã€é€¾æ™‚æˆ–æ¬Šé™æ‹’çµ• â†’ å›åˆ°è‡ºåŒ—é è¨­
                            selectEl.selectedIndex = defaultIdx >= 0 ? defaultIdx : 0;
                            renderWeather(cities[selectEl.selectedIndex].data);
                        });

                        selectEl.onchange = () => {
                            const idx = parseInt(selectEl.value, 10);
                            if (cities[idx]) {
                                if (locNameEl) locNameEl.textContent = cities[idx].label;
                                renderWeather(cities[idx].data);
                            }
                        };
                    } else if (cities.length === 1) {
                        selectEl.style.display = 'none';
                        locNameEl.style.display = 'inline';
                        locNameEl.textContent = cities[0].label;
                        renderWeather(cities[0].data);
                    } else {
                        // fallback: try to pick a single city
                        const chosen = pickCityData(json.data) || json.data;
                        if (!chosen || !chosen.forecasts) throw new Error('æ‰¾ä¸åˆ°é©åˆçš„åŸå¸‚è³‡æ–™');
                        selectEl.style.display = 'none';
                        locNameEl.style.display = 'inline';
                        locNameEl.textContent = chosen.city || chosen.locationName || chosen.name || locNameEl.textContent;
                        renderWeather(chosen);
                    }

                    // è³‡æ–™è™•ç†å¥½å¾Œï¼Œéš±è— Loadingï¼Œé¡¯ç¤ºä¸»ç•«é¢
                    document.getElementById('loading').style.display = 'none';
                    document.getElementById('mainContent').style.display = 'block';
                } else {
                    throw new Error("API Error");
                }
            } catch (e) {
                console.error(e);
                alert("å¤©æ°£è³‡æ–™è®€å–å¤±æ•—ï¼Œç‹¸å…‹æŠŠç¶²è·¯ç·šå’¬æ–·äº†ï¼");
            }
        }

        document.addEventListener("DOMContentLoaded", fetchWeather);
    </script>
</body>

</html>